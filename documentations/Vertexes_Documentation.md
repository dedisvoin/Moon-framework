# Документация модуля Vertexes

## Обзор

Модуль `Vertexes` предоставляет мощные инструменты для работы с массивами вершин в библиотеке Moon. Он обеспечивает эффективное управление геометрическими данными для рендеринга различных графических примитивов с поддержкой позиций, цветов и текстурных координат.

**Версия:** 1.0.0  
**Автор:** Павлов Иван (Pavlov Ivan)  
**Лицензия:** MIT  
**Реализация:** 95%

## Основные возможности

- ✅ Эффективное управление массивами вершин через нативный код
- ✅ Поддержка всех основных типов примитивов OpenGL
- ✅ Легковесный класс Vertex с оптимизацией памяти
- ✅ Быстрые операции изменения отдельных атрибутов вершин
- ✅ Массовые операции для работы с множественными вершинами
- ✅ Автоматическое управление ресурсами и памятью

## Требования

- Python 3.8+
- Библиотека `ctypes` (для работы с DLL)
- Moon.dll (нативная библиотека рендеринга)
- Moon.Colors (модуль цветов)
- Moon.Vectors (модуль векторов)

---

## Классы

### Vertex

Легковесный контейнер для данных вершины с оптимизацией памяти через `__slots__`.

#### Конструктор

```python
Vertex(pos: Vector2f = None, color: Color = None, tex_coords: Vector2f = None)
```

**Параметры:**
- `pos` - позиция вершины в пространстве (по умолчанию (0,0))
- `color` - цвет вершины (по умолчанию черный)
- `tex_coords` - текстурные координаты (по умолчанию (0,0))

#### Атрибуты

**position (Vector2f)**
Позиция вершины в 2D пространстве. Определяет где будет отрисована вершина на экране или в мировых координатах.

**color (Color)**
Цвет вершины с поддержкой альфа-канала. Используется для окрашивания примитивов или смешивания с текстурами.

**tex_coords (Vector2f)**
Текстурные координаты для наложения изображений. Обычно в диапазоне 0.0-1.0, где (0,0) - левый верхний угол текстуры, (1,1) - правый нижний.

#### Методы

```python
def __repr__() -> str
```
**Описание:** Возвращает строковое представление вершины для отладки. Включает все основные атрибуты в читаемом формате.

**Возвращает:** Форматированная строка с данными вершины

---

### VertexArray

Основной класс для управления массивами вершин и их рендеринга.

#### Конструктор

```python
VertexArray()
```

**Описание:** Создает пустой массив вершин с нативным управлением памятью. Инициализирует внутренние структуры для хранения вершинных данных и устанавливает тип примитива по умолчанию.

**Исключения:** `RuntimeError` при ошибке создания нативного объекта

#### Типы примитивов (VertexArray.PrimitiveType)

```python
POINTS = 0          # Отдельные точки
LINES = 1           # Пары вершин как отдельные линии  
LINE_STRIP = 2      # Связанные линии (полилиния)
TRIANGLES = 3       # Тройки вершин как треугольники
TRIANGLE_STRIP = 4  # Полоса соединенных треугольников
TRIANGLE_FAN = 5    # Веер треугольников
QUADS = 6           # Четверки вершин как четырехугольники
```

#### Основные методы

##### Управление массивом

**Размер и доступ**

```python
def __len__() -> int
```
**Описание:** Возвращает текущее количество вершин в массиве. Использует нативный счетчик для максимальной производительности.

**Возвращает:** Количество вершин в массиве

---

```python
def __getitem__(index: int) -> Vertex
```
**Описание:** Получает копию вершины по индексу из нативного массива. Возвращенная вершина является независимой копией - изменения в ней НЕ влияют на массив. Для обновления данных используйте `set_vertex()`.

**Параметры:**
- `index` - индекс вершины (0 <= index < len(array))

**Возвращает:** Копия вершины с данными из массива

**Исключения:** `IndexError` при выходе индекса за границы

---

```python
def resize(size: int) -> None
```
**Описание:** Изменяет размер массива вершин. При уменьшении лишние вершины удаляются, при увеличении новые вершины инициализируются значениями по умолчанию. Операция выполняется эффективно в нативном коде.

**Параметры:**
- `size` - новый размер массива (должен быть >= 0)

**Исключения:** `ValueError` при передаче отрицательного размера

---

```python
def clear() -> None
```
**Описание:** Удаляет все вершины из массива и освобождает занятую ими память. Сбрасывает размер массива до нуля, но сохраняет установленный тип примитива.

---

**Тип примитива**

```python
def set_primitive_type(primitive_type: PrimitiveType) -> Self
```
**Описание:** Устанавливает тип примитива, определяющий способ интерпретации вершин при рендеринге. Влияет на то, как OpenGL соединяет вершины в геометрические фигуры.

**Параметры:**
- `primitive_type` - тип примитива из перечисления `PrimitiveType`

**Возвращает:** `Self` для цепочки вызовов

**Исключения:** `TypeError` при передаче неверного типа

---

```python
def get_primitive_type() -> PrimitiveType
```
**Описание:** Возвращает текущий установленный тип примитива для массива вершин.

**Возвращает:** Текущий тип примитива из перечисления `PrimitiveType`

---

##### Добавление вершин

**Базовые операции**

```python
def append(vertex: Vertex) -> None
```
**Описание:** Добавляет вершину в конец массива, увеличивая его размер на единицу. Автоматически определяет наличие текстурных координат и вызывает соответствующую оптимизированную нативную функцию.

**Параметры:**
- `vertex` - вершина для добавления

**Исключения:** `TypeError` при передаче объекта неверного типа

---

```python
def extend(vertices: list[Vertex]) -> None
```
**Описание:** Добавляет множество вершин в массив последовательными вызовами `append()`. Эквивалентно циклу добавления отдельных вершин.

**Параметры:**
- `vertices` - список вершин для добавления

---

```python
def add_vertices(vertices: list[Vertex]) -> Self
```
**Описание:** Аналог `extend()`, но возвращает `self` для поддержки цепочки вызовов методов. Позволяет комбинировать операции в одном выражении.

**Параметры:**
- `vertices` - список вершин для добавления

**Возвращает:** `Self` для цепочки вызовов

---

**Оптимизированные операции**

```python
def add_vertex_with_texture(x: float, y: float, color: Color, tex_x: float, tex_y: float) -> None
```
**Описание:** Прямое добавление вершины с указанием всех параметров без создания промежуточного объекта `Vertex`. Оптимизированная версия для случаев, когда производительность критична.

**Параметры:**
- `x` - X координата позиции
- `y` - Y координата позиции  
- `color` - цвет вершины
- `tex_x` - X координата текстуры
- `tex_y` - Y координата текстуры

---

```python
def add_textured_quad(x: float, y: float, width: float, height: float, color: Color, 
                     tex_left: float, tex_top: float, tex_width: float, tex_height: float) -> None
```
**Описание:** Добавляет готовый текстурированный четырехугольник из четырех вершин. Автоматически вычисляет позиции углов и соответствующие текстурные координаты.

**Параметры:**
- `x`, `y` - позиция левого верхнего угла
- `width`, `height` - размеры четырехугольника
- `color` - цвет всех вершин
- `tex_left`, `tex_top` - начальные текстурные координаты
- `tex_width`, `tex_height` - размер области текстуры

---

##### Изменение вершин

**Полная замена**

```python
def set_vertex(index: int, vertex: Vertex) -> None
```
**Описание:** Заменяет существующую вершину по указанному индексу. Копирует все атрибуты (позицию, цвет, текстурные координаты) из нового объекта в нативный массив.

**Параметры:**
- `index` - индекс заменяемой вершины
- `vertex` - новые данные вершины

**Исключения:** 
- `TypeError` при передаче неверного типа
- `IndexError` при выходе индекса за границы

---

**Частичные обновления**

```python
def set_vertex_position(index: int, x: float, y: float) -> None
```
**Описание:** Быстро обновляет только позицию указанной вершины, не затрагивая цвет и текстурные координаты. Оптимизированная операция для частых изменений позиций.

**Параметры:**
- `index` - индекс вершины
- `x` - новая X координата
- `y` - новая Y координата

**Исключения:** `IndexError` при выходе индекса за границы

---

```python
def set_vertex_color(index: int, color: Color) -> None
```
**Описание:** Быстро обновляет только цвет указанной вершины, сохраняя позицию и текстурные координаты без изменений. Эффективная операция для динамического изменения цветов.

**Параметры:**
- `index` - индекс вершины
- `color` - новый цвет вершины

**Исключения:** `IndexError` при выходе индекса за границы

---

```python
def set_color(color: Color) -> None
```
**Описание:** Применяет один цвет ко всем вершинам в массиве одновременно. Эффективная массовая операция, которая сохраняет позиции и текстурные координаты всех вершин.

**Параметры:**
- `color` - цвет для применения ко всем вершинам

---

##### Текстурные координаты

**Отдельные вершины**

```python
def set_vertex_texture_coords(index: int, tex_x: float, tex_y: float) -> None
```
**Описание:** Устанавливает текстурные координаты для конкретной вершины, не изменяя её позицию и цвет. Координаты обычно находятся в диапазоне 0.0-1.0.

**Параметры:**
- `index` - индекс вершины
- `tex_x` - X координата текстуры (обычно 0.0-1.0)
- `tex_y` - Y координата текстуры (обычно 0.0-1.0)

**Исключения:** `IndexError` при выходе индекса за границы

---

**Четырехугольники**

```python
def set_quad_texture_coords(start_index: int, tex_left: float = 0.0, tex_top: float = 0.0, 
                           tex_right: float = 1.0, tex_bottom: float = 1.0) -> None
```
**Описание:** Автоматически устанавливает текстурные координаты для четырех последовательных вершин, формирующих четырехугольник. Распределяет координаты по углам в правильном порядке.

**Параметры:**
- `start_index` - индекс первой вершины четырехугольника
- `tex_left` - левая граница текстуры (по умолчанию 0.0)
- `tex_top` - верхняя граница текстуры (по умолчанию 0.0)
- `tex_right` - правая граница текстуры (по умолчанию 1.0)
- `tex_bottom` - нижняя граница текстуры (по умолчанию 1.0)

---

```python
def set_quad_texture_coords(start_index: int, left: float, top: float, width: float, height: float) -> None
```
**Описание:** Альтернативная версия для установки текстурных координат четырехугольника через позицию и размер области текстуры.

**Параметры:**
- `start_index` - индекс первой вершины
- `left`, `top` - начальная позиция в текстуре
- `width`, `height` - размер области текстуры

**Исключения:** `IndexError` если четырехугольник выходит за границы массива

---

#### Служебные методы

```python
def get_ptr()
```
**Описание:** Возвращает указатель на нативный объект массива для использования в C++ коде библиотеки Moon. Предназначен для внутреннего использования системой рендеринга.

**Возвращает:** `ctypes.c_void_p` указатель на нативный объект

---

```python
def __del__()
```
**Описание:** Автоматически освобождает ресурсы нативного массива при удалении объекта Python. Предотвращает утечки памяти и корректно завершает работу с нативными ресурсами.

---

## Примеры использования

### Создание простого треугольника

```python
from Moon.python.Rendering.Vertexes import VertexArray, Vertex
from Moon.python.Vectors import Vector2f
from Moon.python.Colors import Color

# Создание массива для треугольника
triangle = VertexArray()
triangle.set_primitive_type(VertexArray.PrimitiveType.TRIANGLES)

# Добавление вершин треугольника
triangle.append(Vertex(Vector2f(400, 200), Color(255, 0, 0)))    # Красная вершина
triangle.append(Vertex(Vector2f(300, 400), Color(0, 255, 0)))    # Зеленая вершина  
triangle.append(Vertex(Vector2f(500, 400), Color(0, 0, 255)))    # Синяя вершина

# Отрисовка
window.draw(triangle)
```

### Текстурированный четырехугольник

```python
# Создание массива для квада
quad = VertexArray()
quad.set_primitive_type(VertexArray.PrimitiveType.QUADS)

# Белый цвет для правильного отображения текстуры
white = Color(255, 255, 255, 255)

# Добавление вершин с текстурными координатами
quad.append(Vertex(Vector2f(100, 100), white, Vector2f(0, 0)))    # Левый верхний
quad.append(Vertex(Vector2f(200, 100), white, Vector2f(1, 0)))    # Правый верхний
quad.append(Vertex(Vector2f(200, 200), white, Vector2f(1, 1)))    # Правый нижний
quad.append(Vertex(Vector2f(100, 200), white, Vector2f(0, 1)))    # Левый нижний

# Отрисовка с текстурой
render_states = RenderStates().set_texture(my_texture)
window.draw(quad, render_states)
```

### Динамическое изменение вершин

```python
# Создание массива точек
points = VertexArray()
points.set_primitive_type(VertexArray.PrimitiveType.POINTS)

# Добавление начальных точек
for i in range(100):
    x = random.uniform(0, 800)
    y = random.uniform(0, 600)
    color = Color(random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
    points.append(Vertex(Vector2f(x, y), color))

# В игровом цикле - анимация точек
for i in range(len(points)):
    # Получаем текущую позицию
    current_vertex = points[i]
    
    # Обновляем позицию
    new_x = current_vertex.position.x + random.uniform(-1, 1)
    new_y = current_vertex.position.y + random.uniform(-1, 1)
    points.set_vertex_position(i, new_x, new_y)
    
    # Изменяем цвет
    new_color = Color(random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
    points.set_vertex_color(i, new_color)
```

### Оптимизированное добавление вершин

```python
# Создание большого массива эффективным способом
particles = VertexArray()
particles.set_primitive_type(VertexArray.PrimitiveType.QUADS)

# Предварительное выделение памяти
particles.resize(1000 * 4)  # 1000 квадов = 4000 вершин

# Быстрое заполнение без создания промежуточных объектов
for i in range(1000):
    x = random.uniform(0, 800)
    y = random.uniform(0, 600)
    size = random.uniform(2, 8)
    color = Color(255, 255, 255, random.randint(100, 255))
    
    # Добавляем готовый текстурированный квад
    particles.add_textured_quad(
        x, y, size, size, color,
        0.0, 0.0, 1.0, 1.0  # Полная текстура
    )
```

### Работа с различными примитивами

```python
# Линии
lines = VertexArray()
lines.set_primitive_type(VertexArray.PrimitiveType.LINES)
lines.append(Vertex(Vector2f(0, 0), Color(255, 255, 255)))
lines.append(Vertex(Vector2f(100, 100), Color(255, 255, 255)))

# Полилиния
line_strip = VertexArray()
line_strip.set_primitive_type(VertexArray.PrimitiveType.LINE_STRIP)
for i in range(10):
    x = i * 50
    y = math.sin(i * 0.5) * 100 + 300
    line_strip.append(Vertex(Vector2f(x, y), Color(0, 255, 0)))

# Веер треугольников
fan = VertexArray()
fan.set_primitive_type(VertexArray.PrimitiveType.TRIANGLE_FAN)
fan.append(Vertex(Vector2f(400, 300), Color(255, 255, 255)))  # Центр
for angle in range(0, 360, 30):
    rad = math.radians(angle)
    x = 400 + math.cos(rad) * 100
    y = 300 + math.sin(rad) * 100
    fan.append(Vertex(Vector2f(x, y), Color(255, 0, 0)))
```

### Массовые операции

```python
# Создание массива
array = VertexArray()
array.set_primitive_type(VertexArray.PrimitiveType.TRIANGLES)

# Добавление множества вершин
vertices = []
for i in range(300):  # 100 треугольников
    vertices.append(Vertex(Vector2f(random.uniform(0, 800), random.uniform(0, 600)), 
                          Color(random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))))

# Эффективное добавление всех вершин
array.add_vertices(vertices).set_primitive_type(VertexArray.PrimitiveType.TRIANGLES)

# Изменение цвета всех вершин
array.set_color(Color(128, 128, 128, 200))  # Полупрозрачный серый
```

---

## Рекомендации по использованию

### Производительность

- **Предварительное выделение памяти:** Используйте `resize()` для больших массивов вместо множественных `append()`
- **Массовые операции:** Предпочитайте `add_vertices()` и `set_color()` для работы с множественными элементами
- **Прямые методы:** Используйте `add_vertex_with_texture()` вместо создания промежуточных объектов `Vertex`
- **Частичные обновления:** Применяйте `set_vertex_position()` и `set_vertex_color()` для изменения отдельных атрибутов

### Типы примитивов

- **POINTS:** Для систем частиц и точечных эффектов
- **LINES:** Для отдельных линий и сеток
- **LINE_STRIP:** Для непрерывных линий и контуров
- **TRIANGLES:** Для произвольной геометрии и мешей
- **TRIANGLE_STRIP/FAN:** Для оптимизированных поверхностей
- **QUADS:** Для прямоугольных объектов и спрайтов

### Текстурирование

- Используйте белый цвет (`Color(255, 255, 255)`) для правильного отображения текстур
- Текстурные координаты обычно в диапазоне 0.0-1.0
- Применяйте `set_quad_texture_coords()` для автоматической настройки четырехугольников
- Координата (0,0) соответствует левому верхнему углу текстуры

### Управление памятью

- Объекты `VertexArray` автоматически освобождают нативную память при удалении
- Избегайте создания множества временных массивов в циклах
- Переиспользуйте массивы через `clear()` вместо создания новых
- Контролируйте размер массивов для оптимального использования памяти

---

## Лицензия

MIT License - Copyright (c) 2025 Pavlov Ivan

Разрешается свободное использование, копирование, изменение и распространение при условии сохранения уведомления об авторских правах.